//! <center>
//! <img src="https://github.com/Arrow-air/tf-github/raw/main/src/templates/doc-banner-services.png" style="height:250px" />
//! </center>
//! <div align="center">
//!     <a href="https://github.com/Arrow-air/svc-telemetry/releases">
//!         <img src="https://img.shields.io/github/v/release/Arrow-air/svc-telemetry?include_prereleases" alt="GitHub release (latest by date including pre-releases)">
//!     </a>
//!     <a href="https://github.com/Arrow-air/svc-telemetry/tree/main">
//!         <img src="https://github.com/arrow-air/svc-telemetry/actions/workflows/rust_ci.yml/badge.svg?branch=main" alt="Rust Checks">
//!     </a>
//!     <a href="https://discord.com/invite/arrow">
//!         <img src="https://img.shields.io/discord/853833144037277726?style=plastic" alt="Arrow DAO Discord">
//!     </a>
//!     <br><br>
//! </div>
//!
//! `svc-telemetry` exposes a REST API for networked assets to post telemetry.
//!  It also broadcasts aircraft and vertiport location data.

#[allow(dead_code)]
mod grpc_clients;

/// Module autogenerated from grpc.proto
pub mod grpc {
    #![allow(unused_qualifications, missing_docs)]
    include!("grpc.rs");
}

/// REST API handlers
mod rest_api;

/// Redis servers
mod cache;

use axum::{extract::Extension, handler::Handler, response::IntoResponse, routing, Router};
use cache::RedisPool;
use clap::Parser;
use grpc::svc_telemetry_rpc_server::{SvcTelemetryRpc, SvcTelemetryRpcServer};
use grpc::{QueryIsReady, ReadyResponse};
use grpc_clients::GrpcClients;
use log::{error, info, warn};
use tonic::{transport::Server, Request, Response, Status};
use utoipa::OpenApi;

/// Mavlink entries in the cache will expire after 5 seconds
const CACHE_EXPIRE_MS_MAVLINK_ADSB: u32 = 5000;

/// Mavlink entries in the cache will expire after 10 seconds
const CACHE_EXPIRE_MS_AIRCRAFT_ADSB: u32 = 10000;

#[derive(Parser, Debug)]
struct Cli {
    /// Target file to write the OpenAPI Spec
    #[arg(long)]
    openapi: Option<String>,
}

#[derive(OpenApi)]
#[openapi(
    paths(
        rest_api::mavlink_adsb,
    ),
    tags(
        (name = "svc-telemetry", description = "svc-telemetry REST API")
    )
)]
struct ApiDoc;

///Implementation of gRPC endpoints
#[derive(Debug, Default, Copy, Clone)]
pub struct SvcTelemetryImpl {}

#[tonic::async_trait]
impl SvcTelemetryRpc for SvcTelemetryImpl {
    /// Returns ready:true when service is available
    #[cfg(not(tarpaulin_include))]
    async fn is_ready(
        &self,
        _request: Request<QueryIsReady>,
    ) -> Result<Response<ReadyResponse>, Status> {
        let response = ReadyResponse { ready: true };
        Ok(Response::new(response))
    }
}

/// Responds a NOT_FOUND status and error string
///
/// # Arguments
///
/// # Examples
///
/// ```
/// let app = Router::new()
///         .fallback(not_found.into_service());
/// ```
async fn not_found(uri: axum::http::Uri) -> impl IntoResponse {
    (
        axum::http::StatusCode::NOT_FOUND,
        format!("No route {}", uri),
    )
}

/// Tokio signal handler that will wait for a user to press CTRL+C.
/// We use this in our hyper `Server` method `with_graceful_shutdown`.
///
/// # Arguments
///
/// # Examples
///
/// ```
/// Server::bind(&"0.0.0.0:8000".parse().unwrap())
/// .serve(app.into_make_service())
/// .with_graceful_shutdown(shutdown_signal())
/// .await
/// .unwrap();
/// ```
async fn shutdown_signal(server: &str) {
    tokio::signal::ctrl_c()
        .await
        .expect("expect tokio signal ctrl-c");
    warn!("({}) shutdown signal", server);
}

/// Starts the grpc server for this microservice
#[cfg(not(tarpaulin_include))]
async fn grpc_server() {
    // GRPC Server
    let grpc_port = std::env::var("DOCKER_PORT_GRPC")
        .unwrap_or_else(|_| "50051".to_string())
        .parse::<u16>()
        .unwrap_or(50051);

    let full_grpc_addr = format!("[::]:{}", grpc_port).parse().unwrap();
    let imp = SvcTelemetryImpl::default();
    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();
    health_reporter
        .set_serving::<SvcTelemetryRpcServer<SvcTelemetryImpl>>()
        .await;

    //start server
    info!("(grpc) hosted at {}", full_grpc_addr);
    Server::builder()
        .add_service(health_service)
        .add_service(SvcTelemetryRpcServer::new(imp))
        .serve(full_grpc_addr)
        .await
        .unwrap();
}

/// Starts the REST API server for this microservice
#[cfg(not(tarpaulin_include))]
pub async fn rest_server(
    grpc_clients: GrpcClients,
    mavlink_cache: RedisPool,
    adsb_cache: RedisPool,
) {
    let rest_port = std::env::var("DOCKER_PORT_REST")
        .unwrap_or_else(|_| "8000".to_string())
        .parse::<u16>()
        .unwrap_or(8000);

    let app = Router::new()
        .fallback(not_found.into_service())
        .route(
            "/telemetry/mavlink/adsb",
            routing::post(rest_api::mavlink_adsb),
        )
        .route("/telemetry/aircraft/adsb", routing::post(rest_api::adsb))
        .layer(Extension(mavlink_cache))
        .layer(Extension(adsb_cache))
        .layer(Extension(grpc_clients));

    let address = format!("[::]:{rest_port}").parse().unwrap();
    info!("(rest) hosted at {:?}", address);
    axum::Server::bind(&address)
        .serve(app.into_make_service())
        .with_graceful_shutdown(shutdown_signal("rest"))
        .await
        .unwrap();
}

/// Create OpenAPI3 Specification File
fn generate_openapi_spec(target: &str) -> Result<(), Box<dyn std::error::Error>> {
    let output = ApiDoc::openapi()
        .to_pretty_json()
        .expect("(ERROR) unable to write openapi specification to json.");

    std::fs::write(target, output).expect("(ERROR) unable to write json string to file.");

    Ok(())
}

#[cfg(not(tarpaulin_include))]
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Allow option to only generate the spec file to a given location
    let args = Cli::parse();
    if let Some(target) = args.openapi {
        return generate_openapi_spec(&target);
    }

    // Start Logger
    let log_cfg: &str = "log4rs.yaml";
    if let Err(e) = log4rs::init_file(log_cfg, Default::default()) {
        error!("(logger) could not parse {}. {}", log_cfg, e);
        panic!();
    }

    // Start GRPC Server
    tokio::spawn(grpc_server());

    // Start REST API
    rest_server(
        GrpcClients::default(),
        // Mavlink cache
        RedisPool::new(CACHE_EXPIRE_MS_MAVLINK_ADSB)
            .await
            .expect("Could not start redis server."),
        // Standard aircraft ADS-B cache
        RedisPool::new(CACHE_EXPIRE_MS_AIRCRAFT_ADSB)
            .await
            .expect("Could not start redis server."),
    )
    .await;

    info!("Successful shutdown.");
    Ok(())
}
